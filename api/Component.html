---
layout: default
title: "Component API"
categories:
  - api
---
  <div class="row-fluid">
    <div class="page-title documentation-page-title">
      <div class="container">
        <h1 class="page-title__title">API Documentation</h1>
        <a href="https://github.com/noflo/noflo/blob/master/src/lib/Component.js" class="btn btn-primary page-title__button big-button">On GitHub</a>
      </div>
    </div>
  </div>

  <div class="row-fluid">
    <div class="container documentation-main-container">
      <div class="main">
        <div class="sidebar span4">
        
          <nav>
            <ul class="sidebar__nav">
              
                
                
                <li>
                  <a {% if page.url == '/api/AsCallback/index.html' %}class="active" {% endif %}href="/api/AsCallback/">
                    AsCallback
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/AsComponent/index.html' %}class="active" {% endif %}href="/api/AsComponent/">
                    AsComponent
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/BaseNetwork/index.html' %}class="active" {% endif %}href="/api/BaseNetwork/">
                    BaseNetwork
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/BasePort/index.html' %}class="active" {% endif %}href="/api/BasePort/">
                    BasePort
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Component/index.html' %}class="active" {% endif %}href="/api/Component/">
                    Component
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/ComponentLoader/index.html' %}class="active" {% endif %}href="/api/ComponentLoader/">
                    ComponentLoader
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/IP/index.html' %}class="active" {% endif %}href="/api/IP/">
                    IP
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/InPort/index.html' %}class="active" {% endif %}href="/api/InPort/">
                    InPort
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/InternalSocket/index.html' %}class="active" {% endif %}href="/api/InternalSocket/">
                    InternalSocket
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/LegacyNetwork/index.html' %}class="active" {% endif %}href="/api/LegacyNetwork/">
                    LegacyNetwork
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Network/index.html' %}class="active" {% endif %}href="/api/Network/">
                    Network
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/NoFlo/index.html' %}class="active" {% endif %}href="/api/NoFlo/">
                    NoFlo
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/OutPort/index.html' %}class="active" {% endif %}href="/api/OutPort/">
                    OutPort
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Platform/index.html' %}class="active" {% endif %}href="/api/Platform/">
                    Platform
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Ports/index.html' %}class="active" {% endif %}href="/api/Ports/">
                    Ports
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/ProcessContext/index.html' %}class="active" {% endif %}href="/api/ProcessContext/">
                    ProcessContext
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/ProcessInput/index.html' %}class="active" {% endif %}href="/api/ProcessInput/">
                    ProcessInput
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/ProcessOutput/index.html' %}class="active" {% endif %}href="/api/ProcessOutput/">
                    ProcessOutput
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Utils/index.html' %}class="active" {% endif %}href="/api/Utils/">
                    Utils
                  </a>
                </li>
                
              
            </ul>
          </nav>
        
        </div>
        <div class="content span8">
          <h1>{{ page.title }}</h1>
          
            
            <pre><code>NoFlo - Flow-Based Programming <span class="hljs-keyword">for</span> JavaScript
(c) <span class="hljs-number">2013</span><span class="hljs-number">-2017</span> Flowhub UG
(c) <span class="hljs-number">2011</span><span class="hljs-number">-2012</span> Henri Bergius, Nemein
NoFlo may be freely distributed under the MIT license</code></pre>

            
              <div class='highlight'><pre>
<span class="hljs-comment">/* eslint-disable
    class-methods-use-this,
    no-underscore-dangle,
    import/prefer-default-export,
*/</span>
<span class="hljs-keyword">import</span> { EventEmitter } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;events&#x27;</span>;
<span class="hljs-keyword">import</span> debug <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;debug&#x27;</span>;
<span class="hljs-keyword">import</span> { InPorts, OutPorts, normalizePortName } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Ports&#x27;</span>;
<span class="hljs-keyword">import</span> { deprecated } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Platform&#x27;</span>;
<span class="hljs-keyword">import</span> InPort <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./InPort&#x27;</span>; <span class="hljs-comment">// eslint-disable-line no-unused-vars</span>
<span class="hljs-keyword">import</span> OutPort <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./OutPort&#x27;</span>; <span class="hljs-comment">// eslint-disable-line no-unused-vars</span>
<span class="hljs-keyword">import</span> ProcessContext <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ProcessContext&#x27;</span>;
<span class="hljs-keyword">import</span> ProcessInput <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ProcessInput&#x27;</span>;
<span class="hljs-keyword">import</span> ProcessOutput <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ProcessOutput&#x27;</span>;
<span class="hljs-keyword">import</span> IP <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./IP&#x27;</span>; <span class="hljs-comment">// eslint-disable-line no-unused-vars</span>

<span class="hljs-keyword">const</span> debugComponent = debug(<span class="hljs-string">&#x27;noflo:component&#x27;</span>);
<span class="hljs-keyword">const</span> debugBrackets = debug(<span class="hljs-string">&#x27;noflo:component:brackets&#x27;</span>);
<span class="hljs-keyword">const</span> debugSend = debug(<span class="hljs-string">&#x27;noflo:component:send&#x27;</span>);

<span class="hljs-comment">/**
 * @callback ProcessingFunction
 * @param {ProcessInput} input
 * @param {ProcessOutput} output
 * @param {ProcessContext} context
 * @returns {Promise&lt;any&gt; | void}
 */</span>

<span class="hljs-comment">/**
 * @typedef ComponentOptions
 * @property {import(&quot;./Ports&quot;).InPortsOptions | InPorts} [inPorts] - Inports for the component
 * @property {import(&quot;./Ports&quot;).OutPortsOptions | OutPorts} [outPorts] - Outports for the component
 * @property {string} [icon]
 * @property {string} [description]
 * @property {ProcessingFunction} [options.process] - Component processsing function
 * @property {boolean} [ordered] - Whether component should send
 * packets in same order it received them
 * @property {boolean} [autoOrdering]
 * @property {boolean} [activateOnInput] - Whether component should
 * activate when it receives packets
 * @property {Object&lt;string, Array&lt;string&gt;&gt;} [forwardBrackets] - Mappings of forwarding ports
 */</span>

<span class="hljs-comment">/**
 * @typedef BracketContext
 * @property {Object&lt;string,Object&gt;} in
 * @property {Object&lt;string,Object&gt;} out
 */</span></pre></div>
            
          
            
            <p>eslint-disable-next-line max-len</p>

            
              <div class='highlight'><pre><span class="hljs-comment">/** <span class="hljs-doctag">@typedef <span class="hljs-type">{{ __resolved?: boolean, __bracketClosingAfter?: BracketContext[], [key: string]: any }</span></span>} ProcessResult */</span></pre></div>
            
          
            
            <h2 id="noflo-component-base-class">NoFlo Component Base class</h2>
<p>The <code>noflo.Component</code> interface provides a way to instantiate
and extend NoFlo components.</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span> </span>{
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{ComponentOptions}</span> </span>[options]
   */</span>
  <span class="hljs-keyword">constructor</span>(options = { }) {
    <span class="hljs-built_in">super</span>();
    <span class="hljs-keyword">const</span> opts = options;</pre></div>
            
          
            
            <p>Prepare inports, if any were given in options.
They can also be set up imperatively after component
instantiation by using the <code>component.inPorts.add</code>
method.</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!opts.inPorts) { opts.inPorts = {}; }
    <span class="hljs-keyword">if</span> (opts.inPorts <span class="hljs-keyword">instanceof</span> InPorts) {
      <span class="hljs-built_in">this</span>.inPorts = opts.inPorts;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">this</span>.inPorts = <span class="hljs-keyword">new</span> InPorts(opts.inPorts);
    }</pre></div>
            
          
            
            <p>Prepare outports, if any were given in opts.
They can also be set up imperatively after component
instantiation by using the <code>component.outPorts.add</code>
method.</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!opts.outPorts) { opts.outPorts = {}; }
    <span class="hljs-keyword">if</span> (opts.outPorts <span class="hljs-keyword">instanceof</span> OutPorts) {
      <span class="hljs-built_in">this</span>.outPorts = opts.outPorts;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">this</span>.outPorts = <span class="hljs-keyword">new</span> OutPorts(opts.outPorts);
    }</pre></div>
            
          
            
            <p>Set the default component icon and description</p>

            
              <div class='highlight'><pre>    <span class="hljs-built_in">this</span>.icon = opts.icon ? opts.icon : <span class="hljs-string">&#x27;&#x27;</span>;
    <span class="hljs-built_in">this</span>.description = opts.description ? opts.description : <span class="hljs-string">&#x27;&#x27;</span>;

    <span class="hljs-comment">/** @type {string|null} */</span>
    <span class="hljs-built_in">this</span>.componentName = <span class="hljs-literal">null</span>;
    <span class="hljs-comment">/** @type {string|null} */</span>
    <span class="hljs-built_in">this</span>.baseDir = <span class="hljs-literal">null</span>;</pre></div>
            
          
            
            <p>Initially the component is not started</p>

            
              <div class='highlight'><pre>    <span class="hljs-built_in">this</span>.started = <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">this</span>.load = <span class="hljs-number">0</span>;</pre></div>
            
          
            
            <p>Whether the component should keep send packets
out in the order they were received</p>

            
              <div class='highlight'><pre>    <span class="hljs-built_in">this</span>.ordered = opts.ordered != <span class="hljs-literal">null</span> ? opts.ordered : <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">this</span>.autoOrdering = opts.autoOrdering != <span class="hljs-literal">null</span> ? opts.autoOrdering : <span class="hljs-literal">null</span>;</pre></div>
            
          
            
            <p>Queue for handling ordered output packets</p>

            
              <div class='highlight'><pre>    <span class="hljs-comment">/** <span class="hljs-doctag">@type <span class="hljs-type">{ProcessResult[]}</span> </span>*/</span>
    <span class="hljs-built_in">this</span>.outputQ = [];</pre></div>
            
          
            
            <p>Context used for bracket forwarding</p>

            
              <div class='highlight'><pre>    <span class="hljs-comment">/** <span class="hljs-doctag">@type <span class="hljs-type">{BracketContext}</span> </span>*/</span>
    <span class="hljs-built_in">this</span>.bracketContext = {
      <span class="hljs-attr">in</span>: {},
      <span class="hljs-attr">out</span>: {},
    };</pre></div>
            
          
            
            <p>Whether the component should activate when it
receives packets</p>

            
              <div class='highlight'><pre>    <span class="hljs-built_in">this</span>.activateOnInput = opts.activateOnInput != <span class="hljs-literal">null</span> ? opts.activateOnInput : <span class="hljs-literal">true</span>;</pre></div>
            
          
            
            <p>Bracket forwarding rules. By default we forward
brackets from <code>in</code> port to <code>out</code> and <code>error</code> ports.</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!opts.forwardBrackets) {
      opts.forwardBrackets = { <span class="hljs-attr">in</span>: [<span class="hljs-string">&#x27;out&#x27;</span>, <span class="hljs-string">&#x27;error&#x27;</span>] };
    }
    <span class="hljs-built_in">this</span>.forwardBrackets = opts.forwardBrackets;</pre></div>
            
          
            
            <p>The component’s process function can either be
passed in opts, or given imperatively after
instantation using the <code>component.process</code> method.</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> opts.process === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-built_in">this</span>.process(opts.process);
    }</pre></div>
            
          
            
            <p>Placeholder for the ID of the current node, populated
by NoFlo network</p>

            
              <div class='highlight'><pre>    <span class="hljs-comment">/** <span class="hljs-doctag">@type </span>string | null */</span>
    <span class="hljs-built_in">this</span>.nodeId = <span class="hljs-literal">null</span>;</pre></div>
            
          
            
            <p>Deprecated legacy component connection counter</p>

            
              <div class='highlight'><pre>    <span class="hljs-built_in">this</span>.__openConnections = <span class="hljs-number">0</span>;
  }

  getDescription() { <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.description; }

  isReady() { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }

  isSubgraph() { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> <span class="hljs-variable">icon</span></span> - Updated icon for the component
   */</span>
  setIcon(icon) {
    <span class="hljs-built_in">this</span>.icon = icon;
    <span class="hljs-built_in">this</span>.emit(<span class="hljs-string">&#x27;icon&#x27;</span>, <span class="hljs-built_in">this</span>.icon);
  }

  getIcon() { <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.icon; }</pre></div>
            
          
            
            <h3 id="error-emitting-helper">Error emitting helper</h3>
<p>If component has an <code>error</code> outport that is connected, errors
are sent as IP objects there. If the port is not connected,
errors are thrown.</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{Error}</span> <span class="hljs-variable">e</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{Array&lt;string&gt;}</span> </span>[groups]
   * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> </span>[errorPort]
   * <span class="hljs-doctag">@param <span class="hljs-type">{string | null}</span> </span>[scope]
   */</span>
  error(e, groups = [], errorPort = <span class="hljs-string">&#x27;error&#x27;</span>, scope = <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> outPort = <span class="hljs-comment">/** @type {OutPort} */</span> (<span class="hljs-built_in">this</span>.outPorts.ports[errorPort]);
    <span class="hljs-keyword">if</span> (outPort
      &amp;&amp; (outPort.isAttached() || !outPort.isRequired())) {
      groups.forEach(<span class="hljs-function">(<span class="hljs-params">group</span>) =&gt;</span> {
        outPort.openBracket(group, { scope });
      });
      outPort.data(e, { scope });
      groups.forEach(<span class="hljs-function">(<span class="hljs-params">group</span>) =&gt;</span> {
        outPort.closeBracket(group, { scope });
      });
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">throw</span> e;
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@callback <span class="hljs-variable">ErrorableCallback</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{Error | null}</span> <span class="hljs-variable">error</span></span>
   */</span></pre></div>
            
          
            
            <h3 id="setup">Setup</h3>
<p>The setUp method is for component-specific initialization.
Called at network start-up.</p>
<p>Override in component implementation to do component-specific
setup work.</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{ErrorableCallback}</span> <span class="hljs-variable">callback</span></span> - Callback for when teardown is ready
   * <span class="hljs-doctag">@returns <span class="hljs-type">{Promise&lt;void&gt; | void}</span></span>
   */</span>
  setUp(callback) {
    callback(<span class="hljs-literal">null</span>);
  }</pre></div>
            
          
            
            <h3 id="teardown">Teardown</h3>
<p>The tearDown method is for component-specific cleanup. Called
at network shutdown</p>
<p>Override in component implementation to do component-specific
cleanup work, like clearing any accumulated state.</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{ErrorableCallback}</span> <span class="hljs-variable">callback</span></span> - Callback for when teardown is ready
   * <span class="hljs-doctag">@returns <span class="hljs-type">{Promise&lt;void&gt; | void}</span></span>
   */</span>
  tearDown(callback) {
    callback(<span class="hljs-literal">null</span>);
  }</pre></div>
            
          
            
            <h3 id="start">Start</h3>
<p>Called when network starts. This sets calls the setUp
method and sets the component to a started state.</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{ErrorableCallback}</span> </span>[callback] - Callback for when shutdown is ready
   * <span class="hljs-doctag">@returns <span class="hljs-type">{Promise&lt;void&gt;}</span></span>
   */</span>
  start(callback) {
    <span class="hljs-keyword">let</span> promise;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isStarted()) {
      promise = <span class="hljs-built_in">Promise</span>.resolve();
    } <span class="hljs-keyword">else</span> {
      promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">this</span>.setUp(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (err) {
            reject(err);
            <span class="hljs-keyword">return</span>;
          }
          resolve();
        });
        <span class="hljs-keyword">if</span> (res &amp;&amp; res.then) {</pre></div>
            
          
            
            <p>setUp returned a Promise</p>

            
              <div class='highlight'><pre>          res.then(resolve, reject);
        }
      })
        .then(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-built_in">this</span>.started = <span class="hljs-literal">true</span>;
          <span class="hljs-built_in">this</span>.emit(<span class="hljs-string">&#x27;start&#x27;</span>);
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();
        });
    }
    <span class="hljs-keyword">if</span> (callback) {
      deprecated(<span class="hljs-string">&#x27;Providing a callback to Component.start is deprecated, use Promises&#x27;</span>);
      promise.then(<span class="hljs-function">() =&gt;</span> {
        callback(<span class="hljs-literal">null</span>);
      }, callback);
    }
    <span class="hljs-keyword">return</span> promise;
  }</pre></div>
            
          
            
            <h3 id="shutdown">Shutdown</h3>
<p>Called when network is shut down. This sets calls the
tearDown method and sets the component back to a
non-started state.</p>
<p>The callback is called when tearDown finishes and
all active processing contexts have ended.</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{ErrorableCallback}</span> </span>[callback] - Callback for when shutdown is ready
   * <span class="hljs-doctag">@returns <span class="hljs-type">{Promise&lt;void&gt;}</span></span>
   */</span>
  shutdown(callback) {
    <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {</pre></div>
            
          
            
            <p>Tell the component that it is time to shut down</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">this</span>.tearDown(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) {
          reject(err);
          <span class="hljs-keyword">return</span>;
        }
        resolve();
      });
      <span class="hljs-keyword">if</span> (res &amp;&amp; res.then) {</pre></div>
            
          
            
            <p>Teardown returned a Promise</p>

            
              <div class='highlight'><pre>        res.then(resolve, reject);
      }
    })
      .then(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.load &gt; <span class="hljs-number">0</span>) {</pre></div>
            
          
            
            <p>Some in-flight processes, wait for them to finish</p>

            
              <div class='highlight'><pre>          <span class="hljs-comment">/**
           * <span class="hljs-doctag">@param <span class="hljs-type">{number}</span> <span class="hljs-variable">load</span></span>
           */</span>
          <span class="hljs-keyword">const</span> checkLoad = <span class="hljs-function">(<span class="hljs-params">load</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (load &gt; <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-built_in">this</span>.removeListener(<span class="hljs-string">&#x27;deactivate&#x27;</span>, checkLoad);
            resolve();
          };
          <span class="hljs-built_in">this</span>.on(<span class="hljs-string">&#x27;deactivate&#x27;</span>, checkLoad);
          <span class="hljs-keyword">return</span>;
        }
        resolve();
      }))
      .then(<span class="hljs-function">() =&gt;</span> {</pre></div>
            
          
            
            <p>Clear contents of inport buffers</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">const</span> inPorts = <span class="hljs-built_in">this</span>.inPorts.ports || <span class="hljs-built_in">this</span>.inPorts;
        <span class="hljs-built_in">Object</span>.keys(inPorts).forEach(<span class="hljs-function">(<span class="hljs-params">portName</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> inPort = <span class="hljs-comment">/** @type {InPort} */</span> (inPorts[portName]);
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> inPort.clear !== <span class="hljs-string">&#x27;function&#x27;</span>) { <span class="hljs-keyword">return</span>; }
          inPort.clear();
        });</pre></div>
            
          
            
            <p>Clear bracket context</p>

            
              <div class='highlight'><pre>        <span class="hljs-built_in">this</span>.bracketContext = {
          <span class="hljs-attr">in</span>: {},
          <span class="hljs-attr">out</span>: {},
        };
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isStarted()) {
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();
        }
        <span class="hljs-built_in">this</span>.started = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">this</span>.emit(<span class="hljs-string">&#x27;end&#x27;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();
      });
    <span class="hljs-keyword">if</span> (callback) {
      deprecated(<span class="hljs-string">&#x27;Providing a callback to Component.shutdown is deprecated, use Promises&#x27;</span>);
      promise.then(<span class="hljs-function">() =&gt;</span> {
        callback(<span class="hljs-literal">null</span>);
      }, callback);
    }
    <span class="hljs-keyword">return</span> promise;
  }

  isStarted() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.started;
  }</pre></div>
            
          
            
            <p>Ensures bracket forwarding map is correct for the existing ports</p>

            
              <div class='highlight'><pre>  prepareForwarding() {
    <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.forwardBrackets).forEach(<span class="hljs-function">(<span class="hljs-params">inPort</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> outPorts = <span class="hljs-built_in">this</span>.forwardBrackets[inPort];
      <span class="hljs-keyword">if</span> (!(inPort <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.inPorts.ports)) {
        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.forwardBrackets[inPort];
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-comment">/** <span class="hljs-doctag">@type <span class="hljs-type">{Array&lt;string&gt;}</span> </span>*/</span>
      <span class="hljs-keyword">const</span> tmp = [];
      outPorts.forEach(<span class="hljs-function">(<span class="hljs-params">outPort</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (outPort <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.outPorts.ports) {
          tmp.push(outPort);
        }
      });
      <span class="hljs-keyword">if</span> (tmp.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.forwardBrackets[inPort];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">this</span>.forwardBrackets[inPort] = tmp;
      }
    });
  }</pre></div>
            
          
            
            <p>Method for determining if a component is using the modern
NoFlo Process API</p>

            
              <div class='highlight'><pre>  isLegacy() {</pre></div>
            
          
            
            <p>Process API</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handle) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }</pre></div>
            
          
            
            <p>Legacy</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }</pre></div>
            
          
            
            <p>Sets process handler function</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{ProcessingFunction}</span> <span class="hljs-variable">handle</span></span> - Processing function
   * <span class="hljs-doctag">@returns <span class="hljs-type">{this}</span></span>
   */</span>
  process(handle) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handle !== <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Process handler must be a function&#x27;</span>);
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inPorts) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Component ports must be defined before process function&#x27;</span>);
    }
    <span class="hljs-built_in">this</span>.prepareForwarding();
    <span class="hljs-built_in">this</span>.handle = handle;
    <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.inPorts.ports).forEach(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> port = <span class="hljs-comment">/** @type {InPort} */</span> (<span class="hljs-built_in">this</span>.inPorts.ports[name]);
      <span class="hljs-keyword">if</span> (!port.name) { port.name = name; }
      port.on(<span class="hljs-string">&#x27;ip&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ip</span>) =&gt;</span> <span class="hljs-built_in">this</span>.handleIP(ip, port));
    });
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
  }</pre></div>
            
          
            
            <p>Method for checking if a given inport is set up for
automatic bracket forwarding</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{InPort|string}</span> <span class="hljs-variable">port</span></span>
   * <span class="hljs-doctag">@returns <span class="hljs-type">{boolean}</span></span>
   */</span>
  isForwardingInport(port) {
    <span class="hljs-keyword">let</span> portName;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> port === <span class="hljs-string">&#x27;string&#x27;</span>) {
      portName = port;
    } <span class="hljs-keyword">else</span> {
      portName = port.name;
    }
    <span class="hljs-keyword">if</span> (portName &amp;&amp; portName <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.forwardBrackets) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }</pre></div>
            
          
            
            <p>Method for checking if a given outport is set up for
automatic bracket forwarding</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{InPort|string}</span> <span class="hljs-variable">inport</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{OutPort|string}</span> <span class="hljs-variable">outport</span></span>
   * <span class="hljs-doctag">@returns <span class="hljs-type">{boolean}</span></span>
   */</span>
  isForwardingOutport(inport, outport) {
    <span class="hljs-keyword">let</span> inportName; <span class="hljs-keyword">let</span>
      outportName;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> inport === <span class="hljs-string">&#x27;string&#x27;</span>) {
      inportName = inport;
    } <span class="hljs-keyword">else</span> {
      inportName = inport.name;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> outport === <span class="hljs-string">&#x27;string&#x27;</span>) {
      outportName = outport;
    } <span class="hljs-keyword">else</span> {
      outportName = outport.name;
    }
    <span class="hljs-keyword">if</span> (!inportName || !outportName) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.forwardBrackets[inportName]) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.forwardBrackets[inportName].indexOf(outportName) !== <span class="hljs-number">-1</span>) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }</pre></div>
            
          
            
            <p>Method for checking whether the component sends packets
in the same order they were received.</p>

            
              <div class='highlight'><pre>  isOrdered() {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.ordered) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.autoOrdering) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }</pre></div>
            
          
            
            <h3 id="handling-ip-objects">Handling IP objects</h3>
<p>The component has received an Information Packet. Call the
processing function so that firing pattern preconditions can
be checked and component can do processing as needed.</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{IP}</span> <span class="hljs-variable">ip</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{InPort}</span> <span class="hljs-variable">port</span></span>
   * <span class="hljs-doctag">@returns <span class="hljs-type">{void}</span></span>
   */</span>
  handleIP(ip, port) {
    <span class="hljs-keyword">if</span> (!port.options.triggering) {</pre></div>
            
          
            
            <p>If port is non-triggering, we can skip the process function call</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> ((ip.type === <span class="hljs-string">&#x27;openBracket&#x27;</span>) &amp;&amp; (<span class="hljs-built_in">this</span>.autoOrdering === <span class="hljs-literal">null</span>) &amp;&amp; !<span class="hljs-built_in">this</span>.ordered) {</pre></div>
            
          
            
            <p>Switch component to ordered mode when receiving a stream unless
auto-ordering is disabled</p>

            
              <div class='highlight'><pre>      debugComponent(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> port &#x27;<span class="hljs-subst">${port.name}</span>&#x27; entered auto-ordering mode`</span>);
      <span class="hljs-built_in">this</span>.autoOrdering = <span class="hljs-literal">true</span>;
    }</pre></div>
            
          
            
            <p>Initialize the result object for situations where output needs
to be queued to be kept in order</p>

            
              <div class='highlight'><pre>    <span class="hljs-comment">/** <span class="hljs-doctag">@type <span class="hljs-type">{ProcessResult}</span> </span>*/</span>
    <span class="hljs-keyword">let</span> result = {};

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isForwardingInport(port)) {</pre></div>
            
          
            
            <p>For bracket-forwarding inports we need to initialize a bracket context
so that brackets can be sent as part of the output, and closed after.</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">&#x27;openBracket&#x27;</span>) {</pre></div>
            
          
            
            <p>For forwarding ports openBrackets don’t fire</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">&#x27;closeBracket&#x27;</span>) {</pre></div>
            
          
            
            <p>For forwarding ports closeBrackets don’t fire
However, we need to handle several different scenarios:
A. There are closeBrackets in queue before current packet
B. There are closeBrackets in queue after current packet
C. We’ve queued the results from all in-flight processes and
   new closeBracket arrives</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">const</span> buf = port.getBuffer(ip.scope, ip.index);
        <span class="hljs-keyword">const</span> dataPackets = buf.filter(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.type === <span class="hljs-string">&#x27;data&#x27;</span>);
        <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.outputQ.length &gt;= <span class="hljs-built_in">this</span>.load) &amp;&amp; (dataPackets.length === <span class="hljs-number">0</span>)) {
          <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] !== ip) { <span class="hljs-keyword">return</span>; }
          <span class="hljs-keyword">if</span> (!port.name) { <span class="hljs-keyword">return</span>; }</pre></div>
            
          
            
            <p>Remove from buffer</p>

            
              <div class='highlight'><pre>          port.get(ip.scope, ip.index);
          <span class="hljs-keyword">const</span> bracketCtx = <span class="hljs-built_in">this</span>.getBracketContext(<span class="hljs-string">&#x27;in&#x27;</span>, port.name, ip.scope, ip.index).pop();
          bracketCtx.closeIp = ip;
          debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> closeBracket-C from &#x27;<span class="hljs-subst">${bracketCtx.source}</span>&#x27; to <span class="hljs-subst">${bracketCtx.ports}</span>: &#x27;<span class="hljs-subst">${ip.data}</span>&#x27;`</span>);
          result = {
            <span class="hljs-attr">__resolved</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">__bracketClosingAfter</span>: [bracketCtx],
          };
          <span class="hljs-built_in">this</span>.outputQ.push(result);
          <span class="hljs-built_in">this</span>.processOutputQueue();
        }</pre></div>
            
          
            
            <p>Check if buffer contains data IPs. If it does, we want to allow
firing</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!dataPackets.length) { <span class="hljs-keyword">return</span>; }
      }
    }</pre></div>
            
          
            
            <p>Prepare the input/output pair</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> ProcessContext(ip, <span class="hljs-built_in">this</span>, port, result);
    <span class="hljs-keyword">const</span> input = <span class="hljs-keyword">new</span> ProcessInput(<span class="hljs-built_in">this</span>.inPorts, context);
    <span class="hljs-keyword">const</span> output = <span class="hljs-keyword">new</span> ProcessOutput(<span class="hljs-built_in">this</span>.outPorts, context);
    <span class="hljs-keyword">try</span> {</pre></div>
            
          
            
            <p>Call the processing function</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.handle) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Processing function not defined&#x27;</span>);
      }
      <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">this</span>.handle(input, output, context);
      <span class="hljs-keyword">if</span> (res &amp;&amp; res.then) {</pre></div>
            
          
            
            <p>Processing function returned a Promise</p>

            
              <div class='highlight'><pre>        res.then(
          <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> output.sendDone(data),
          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> output.done(err),
        );
      }
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-built_in">this</span>.deactivate(context);
      output.sendDone(e);
    }

    <span class="hljs-keyword">if</span> (context.activated) { <span class="hljs-keyword">return</span>; }</pre></div>
            
          
            
            <p>If receiving an IP object didn’t cause the component to
activate, log that input conditions were not met</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (port.isAddressable()) {
      debugComponent(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> packet on &#x27;<span class="hljs-subst">${port.name}</span>[<span class="hljs-subst">${ip.index}</span>]&#x27; didn&#x27;t match preconditions: <span class="hljs-subst">${ip.type}</span>`</span>);
      <span class="hljs-keyword">return</span>;
    }
    debugComponent(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> packet on &#x27;<span class="hljs-subst">${port.name}</span>&#x27; didn&#x27;t match preconditions: <span class="hljs-subst">${ip.type}</span>`</span>);
  }</pre></div>
            
          
            
            <p>Get the current bracket forwarding context for an IP object</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> <span class="hljs-variable">type</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> <span class="hljs-variable">port</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{string|null}</span> <span class="hljs-variable">scope</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{number|null}</span> </span>[idx]
   */</span>
  getBracketContext(type, port, scope, idx = <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">let</span> { name, index } = normalizePortName(port);
    <span class="hljs-keyword">if</span> (idx != <span class="hljs-literal">null</span>) { index = <span class="hljs-string">`<span class="hljs-subst">${idx}</span>`</span>; }
    <span class="hljs-keyword">const</span> portsList = type === <span class="hljs-string">&#x27;in&#x27;</span> ? <span class="hljs-built_in">this</span>.inPorts : <span class="hljs-built_in">this</span>.outPorts;
    <span class="hljs-keyword">if</span> (portsList.ports[name].isAddressable()) {
      name = <span class="hljs-string">`<span class="hljs-subst">${name}</span>[<span class="hljs-subst">${index}</span>]`</span>;
    } <span class="hljs-keyword">else</span> {
      name = port;
    }</pre></div>
            
          
            
            <p>Ensure we have a bracket context for the current scope</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.bracketContext[type][name]) {
      <span class="hljs-built_in">this</span>.bracketContext[type][name] = {};
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.bracketContext[type][name][scope]) {
      <span class="hljs-built_in">this</span>.bracketContext[type][name][scope] = [];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.bracketContext[type][name][scope];
  }</pre></div>
            
          
            
            <p>Add an IP object to the list of results to be sent in
order</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{ProcessResult}</span> <span class="hljs-variable">result</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{Object}</span> <span class="hljs-variable">port</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{IP}</span> <span class="hljs-variable">packet</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{boolean}</span> </span>[before]
   */</span>
  addToResult(result, port, packet, before = <span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">const</span> res = result;
    <span class="hljs-keyword">const</span> ip = packet;
    <span class="hljs-keyword">const</span> { name, index } = normalizePortName(port);
    <span class="hljs-keyword">const</span> method = before ? <span class="hljs-string">&#x27;unshift&#x27;</span> : <span class="hljs-string">&#x27;push&#x27;</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.outPorts.ports[name].isAddressable()) {
      <span class="hljs-keyword">const</span> idx = <span class="hljs-comment">/** @type {number} */</span> (index ? <span class="hljs-built_in">parseInt</span>(index, <span class="hljs-number">10</span>) : ip.index);
      <span class="hljs-keyword">if</span> (!res[name]) {
        res[name] = {};
      }
      <span class="hljs-keyword">if</span> (!res[name][idx]) {
        res[name][idx] = [];
      }
      ip.index = idx;
      res[name][idx][method](ip);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (!res[name]) {
      res[name] = [];
    }
    res[name][method](ip);
  }</pre></div>
            
          
            
            <p>Get contexts that can be forwarded with this in/outport
pair.</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/** <span class="hljs-doctag">@private </span>*/</span>
  getForwardableContexts(inport, outport, contexts) {
    <span class="hljs-keyword">const</span> { name, index } = normalizePortName(outport);
    <span class="hljs-keyword">const</span> forwardable = [];
    contexts.forEach(<span class="hljs-function">(<span class="hljs-params">ctx, idx</span>) =&gt;</span> {</pre></div>
            
          
            
            <p>No forwarding to this outport</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isForwardingOutport(inport, name)) { <span class="hljs-keyword">return</span>; }</pre></div>
            
          
            
            <p>We have already forwarded this context to this outport</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (ctx.ports.indexOf(outport) !== <span class="hljs-number">-1</span>) { <span class="hljs-keyword">return</span>; }</pre></div>
            
          
            
            <p>See if we have already forwarded the same bracket from another
inport</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">const</span> outContext = <span class="hljs-built_in">this</span>.getBracketContext(<span class="hljs-string">&#x27;out&#x27;</span>, name, ctx.ip.scope, <span class="hljs-built_in">parseInt</span>(index, <span class="hljs-number">10</span>))[idx];
      <span class="hljs-keyword">if</span> (outContext) {
        <span class="hljs-keyword">if</span> ((outContext.ip.data === ctx.ip.data) &amp;&amp; (outContext.ports.indexOf(outport) !== <span class="hljs-number">-1</span>)) {
          <span class="hljs-keyword">return</span>;
        }
      }
      forwardable.push(ctx);
    });
    <span class="hljs-keyword">return</span> forwardable;
  }</pre></div>
            
          
            
            <p>Add any bracket forwards needed to the result queue</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/** <span class="hljs-doctag">@private </span>*/</span>
  addBracketForwards(result) {
    <span class="hljs-keyword">const</span> res = result;
    <span class="hljs-keyword">if</span> (res.__bracketClosingBefore != <span class="hljs-literal">null</span> ? res.__bracketClosingBefore.length : <span class="hljs-literal">undefined</span>) {
      res.__bracketClosingBefore.forEach(<span class="hljs-function">(<span class="hljs-params">context</span>) =&gt;</span> {
        debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> closeBracket-A from &#x27;<span class="hljs-subst">${context.source}</span>&#x27; to <span class="hljs-subst">${context.ports}</span>: &#x27;<span class="hljs-subst">${context.closeIp.data}</span>&#x27;`</span>);
        <span class="hljs-keyword">if</span> (!context.ports.length) { <span class="hljs-keyword">return</span>; }
        context.ports.forEach(<span class="hljs-function">(<span class="hljs-params">port</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> ipClone = context.closeIp.clone();
          <span class="hljs-built_in">this</span>.addToResult(res, port, ipClone, <span class="hljs-literal">true</span>);
          <span class="hljs-built_in">this</span>.getBracketContext(<span class="hljs-string">&#x27;out&#x27;</span>, port, ipClone.scope).pop();
        });
      });
    }

    <span class="hljs-keyword">if</span> (res.__bracketContext) {</pre></div>
            
          
            
            <p>First see if there are any brackets to forward. We need to reverse
the keys so that they get added in correct order</p>

            
              <div class='highlight'><pre>      <span class="hljs-built_in">Object</span>.keys(res.__bracketContext).reverse().forEach(<span class="hljs-function">(<span class="hljs-params">inport</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> context = res.__bracketContext[inport];
        <span class="hljs-keyword">if</span> (!context.length) { <span class="hljs-keyword">return</span>; }
        <span class="hljs-built_in">Object</span>.keys(res).forEach(<span class="hljs-function">(<span class="hljs-params">outport</span>) =&gt;</span> {
          <span class="hljs-keyword">let</span> datas; <span class="hljs-keyword">let</span> forwardedOpens; <span class="hljs-keyword">let</span> unforwarded;
          <span class="hljs-keyword">const</span> ips = res[outport];
          <span class="hljs-keyword">if</span> (outport.indexOf(<span class="hljs-string">&#x27;__&#x27;</span>) === <span class="hljs-number">0</span>) { <span class="hljs-keyword">return</span>; }
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.outPorts[outport].isAddressable()) {
            <span class="hljs-built_in">Object</span>.keys(ips).forEach(<span class="hljs-function">(<span class="hljs-params">idx</span>) =&gt;</span> {</pre></div>
            
          
            
            <p>Don’t register indexes we’re only sending brackets to</p>

            
              <div class='highlight'><pre>              <span class="hljs-keyword">const</span> idxIps = ips[idx];
              datas = idxIps.filter(<span class="hljs-function">(<span class="hljs-params">ip</span>) =&gt;</span> ip.type === <span class="hljs-string">&#x27;data&#x27;</span>);
              <span class="hljs-keyword">if</span> (!datas.length) { <span class="hljs-keyword">return</span>; }
              <span class="hljs-keyword">const</span> portIdentifier = <span class="hljs-string">`<span class="hljs-subst">${outport}</span>[<span class="hljs-subst">${idx}</span>]`</span>;
              unforwarded = <span class="hljs-built_in">this</span>.getForwardableContexts(inport, portIdentifier, context);
              <span class="hljs-keyword">if</span> (!unforwarded.length) { <span class="hljs-keyword">return</span>; }
              forwardedOpens = [];
              unforwarded.forEach(<span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> {
                debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> openBracket from &#x27;<span class="hljs-subst">${inport}</span>&#x27; to &#x27;<span class="hljs-subst">${portIdentifier}</span>&#x27;: &#x27;<span class="hljs-subst">${ctx.ip.data}</span>&#x27;`</span>);
                <span class="hljs-keyword">const</span> ipClone = ctx.ip.clone();
                ipClone.index = <span class="hljs-built_in">parseInt</span>(idx, <span class="hljs-number">10</span>);
                forwardedOpens.push(ipClone);
                ctx.ports.push(portIdentifier);
                <span class="hljs-built_in">this</span>.getBracketContext(<span class="hljs-string">&#x27;out&#x27;</span>, outport, ctx.ip.scope, ipClone.index).push(ctx);
              });
              forwardedOpens.reverse();
              forwardedOpens.forEach(<span class="hljs-function">(<span class="hljs-params">ip</span>) =&gt;</span> { <span class="hljs-built_in">this</span>.addToResult(res, outport, ip, <span class="hljs-literal">true</span>); });
            });
            <span class="hljs-keyword">return</span>;
          }</pre></div>
            
          
            
            <p>Don’t register ports we’re only sending brackets to</p>

            
              <div class='highlight'><pre>          datas = ips.filter(<span class="hljs-function">(<span class="hljs-params">ip</span>) =&gt;</span> ip.type === <span class="hljs-string">&#x27;data&#x27;</span>);
          <span class="hljs-keyword">if</span> (!datas.length) { <span class="hljs-keyword">return</span>; }
          unforwarded = <span class="hljs-built_in">this</span>.getForwardableContexts(inport, outport, context);
          <span class="hljs-keyword">if</span> (!unforwarded.length) { <span class="hljs-keyword">return</span>; }
          forwardedOpens = [];
          unforwarded.forEach(<span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> {
            debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> openBracket from &#x27;<span class="hljs-subst">${inport}</span>&#x27; to &#x27;<span class="hljs-subst">${outport}</span>&#x27;: &#x27;<span class="hljs-subst">${ctx.ip.data}</span>&#x27;`</span>);
            forwardedOpens.push(ctx.ip.clone());
            ctx.ports.push(outport);
            <span class="hljs-built_in">this</span>.getBracketContext(<span class="hljs-string">&#x27;out&#x27;</span>, outport, ctx.ip.scope).push(ctx);
          });
          forwardedOpens.reverse();
          forwardedOpens.forEach(<span class="hljs-function">(<span class="hljs-params">ip</span>) =&gt;</span> { <span class="hljs-built_in">this</span>.addToResult(res, outport, ip, <span class="hljs-literal">true</span>); });
        });
      });
    }

    <span class="hljs-keyword">if</span> (res.__bracketClosingAfter != <span class="hljs-literal">null</span> ? res.__bracketClosingAfter.length : <span class="hljs-literal">undefined</span>) {
      res.__bracketClosingAfter.forEach(<span class="hljs-function">(<span class="hljs-params">context</span>) =&gt;</span> {
        debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> closeBracket-B from &#x27;<span class="hljs-subst">${context.source}</span>&#x27; to <span class="hljs-subst">${context.ports}</span>: &#x27;<span class="hljs-subst">${context.closeIp.data}</span>&#x27;`</span>);
        <span class="hljs-keyword">if</span> (!context.ports.length) { <span class="hljs-keyword">return</span>; }
        context.ports.forEach(<span class="hljs-function">(<span class="hljs-params">port</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> ipClone = context.closeIp.clone();
          <span class="hljs-built_in">this</span>.addToResult(res, port, ipClone, <span class="hljs-literal">false</span>);
          <span class="hljs-built_in">this</span>.getBracketContext(<span class="hljs-string">&#x27;out&#x27;</span>, port, ipClone.scope).pop();
        });
      });
    }

    <span class="hljs-keyword">delete</span> res.__bracketClosingBefore;
    <span class="hljs-keyword">delete</span> res.__bracketContext;
    <span class="hljs-keyword">delete</span> res.__bracketClosingAfter;
  }</pre></div>
            
          
            
            <p>Whenever an execution context finishes, send all resolved
output from the queue in the order it is in.</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/** <span class="hljs-doctag">@private </span>*/</span>
  processOutputQueue() {
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.outputQ.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.outputQ[<span class="hljs-number">0</span>].__resolved) { <span class="hljs-keyword">break</span>; }
      <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">this</span>.outputQ.shift();
      <span class="hljs-built_in">this</span>.addBracketForwards(result);
      <span class="hljs-built_in">Object</span>.keys(result).forEach(<span class="hljs-function">(<span class="hljs-params">port</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> portIdentifier;
        <span class="hljs-keyword">const</span> ips = result[port];
        <span class="hljs-keyword">if</span> (port.indexOf(<span class="hljs-string">&#x27;__&#x27;</span>) === <span class="hljs-number">0</span>) { <span class="hljs-keyword">return</span>; }
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.outPorts.ports[port].isAddressable()) {
          <span class="hljs-built_in">Object</span>.keys(ips).forEach(<span class="hljs-function">(<span class="hljs-params">index</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> idxIps = ips[index];
            <span class="hljs-keyword">const</span> idx = <span class="hljs-built_in">parseInt</span>(index, <span class="hljs-number">10</span>);
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.outPorts.ports[port].isAttached(idx)) { <span class="hljs-keyword">return</span>; }
            idxIps.forEach(<span class="hljs-function">(<span class="hljs-params">packet</span>) =&gt;</span> {
              <span class="hljs-keyword">const</span> ip = packet;
              portIdentifier = <span class="hljs-string">`<span class="hljs-subst">${port}</span>[<span class="hljs-subst">${ip.index}</span>]`</span>;
              <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">&#x27;openBracket&#x27;</span>) {
                debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> &lt; &#x27;<span class="hljs-subst">${ip.data}</span>&#x27;`</span>);
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">&#x27;closeBracket&#x27;</span>) {
                debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> &gt; &#x27;<span class="hljs-subst">${ip.data}</span>&#x27;`</span>);
              } <span class="hljs-keyword">else</span> {
                debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> DATA`</span>);
              }
              <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.outPorts[port].options.scoped) {
                ip.scope = <span class="hljs-literal">null</span>;
              }
              <span class="hljs-built_in">this</span>.outPorts[port].sendIP(ip);
            });
          });
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.outPorts.ports[port].isAttached()) { <span class="hljs-keyword">return</span>; }
        ips.forEach(<span class="hljs-function">(<span class="hljs-params">packet</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> ip = packet;
          portIdentifier = port;
          <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">&#x27;openBracket&#x27;</span>) {
            debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> &lt; &#x27;<span class="hljs-subst">${ip.data}</span>&#x27;`</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">&#x27;closeBracket&#x27;</span>) {
            debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> &gt; &#x27;<span class="hljs-subst">${ip.data}</span>&#x27;`</span>);
          } <span class="hljs-keyword">else</span> {
            debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> DATA`</span>);
          }
          <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.outPorts[port].options.scoped) {
            ip.scope = <span class="hljs-literal">null</span>;
          }
          <span class="hljs-built_in">this</span>.outPorts[port].sendIP(ip);
        });
      });
    }
  }</pre></div>
            
          
            
            <p>Signal that component has activated. There may be multiple
activated contexts at the same time</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{Object}</span> <span class="hljs-variable">context</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{boolean}</span> </span>context.activated
   * <span class="hljs-doctag">@param <span class="hljs-type">{boolean}</span> </span>context.deactivated
   * <span class="hljs-doctag">@param <span class="hljs-type">{Object}</span> </span>context.result
   */</span>
  activate(context) {
    <span class="hljs-keyword">if</span> (context.activated) { <span class="hljs-keyword">return</span>; } <span class="hljs-comment">// prevent double activation</span>
    context.activated = <span class="hljs-literal">true</span>;
    context.deactivated = <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">this</span>.load += <span class="hljs-number">1</span>;
    <span class="hljs-built_in">this</span>.emit(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-built_in">this</span>.load);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.ordered || <span class="hljs-built_in">this</span>.autoOrdering) {
      <span class="hljs-built_in">this</span>.outputQ.push(context.result);
    }
  }</pre></div>
            
          
            
            <p>Signal that component has deactivated. There may be multiple
activated contexts at the same time</p>

            
              <div class='highlight'><pre>  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">{Object}</span> <span class="hljs-variable">context</span></span>
   * <span class="hljs-doctag">@param <span class="hljs-type">{boolean}</span> </span>context.activated
   * <span class="hljs-doctag">@param <span class="hljs-type">{boolean}</span> </span>context.deactivated
   */</span>
  deactivate(context) {
    <span class="hljs-keyword">if</span> (context.deactivated) { <span class="hljs-keyword">return</span>; } <span class="hljs-comment">// prevent double deactivation</span>
    context.deactivated = <span class="hljs-literal">true</span>;
    context.activated = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isOrdered()) {
      <span class="hljs-built_in">this</span>.processOutputQueue();
    }
    <span class="hljs-built_in">this</span>.load -= <span class="hljs-number">1</span>;
    <span class="hljs-built_in">this</span>.emit(<span class="hljs-string">&#x27;deactivate&#x27;</span>, <span class="hljs-built_in">this</span>.load);
  }
}
Component.description = <span class="hljs-string">&#x27;&#x27;</span>;
Component.icon = <span class="hljs-literal">null</span>;</pre></div>
            
          
          <p><small>This page contains documentation generated automatically from NoFlo's <a href="https://github.com/noflo/noflo/blob/master/src/lib/Component.js">Component.js</a> file.</small></p>
        </div>
      </div>
    </div>
  </div>
